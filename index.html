<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="好记性不如烂笔头">
<meta property="og:type" content="website">
<meta property="og:title" content="南柯一梦">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="南柯一梦">
<meta property="og:description" content="好记性不如烂笔头">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="曾圣尧">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>南柯一梦</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">南柯一梦</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/21/gtsam%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9AThe%20new%20IMU%20Factor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="曾圣尧">
      <meta itemprop="description" content="好记性不如烂笔头">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南柯一梦">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/21/gtsam%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9AThe%20new%20IMU%20Factor/" class="post-title-link" itemprop="url">gtsam官方文档：The new IMU Factor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-21 19:29:06" itemprop="dateCreated datePublished" datetime="2022-04-21T19:29:06+08:00">2022-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-21 18:11:01" itemprop="dateModified" datetime="2024-01-21T18:11:01+08:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lidar-SLAM/" itemprop="url" rel="index"><span itemprop="name">Lidar SLAM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gtsam官方文档the-new-imu-factor">gtsam官方文档：The new IMU
Factor</h1>
<p>本文为gtsam
imu预积分文档学习笔记，为gtsam基于切向量实现的imu预积分的理论基础。</p>
<h2 id="导航状态">导航状态</h2>
<p>定义导航状态为 <span
class="math inline">\(X^n_b=\{R^n_b,P^n_b,V^n_b\}\)</span></p>
<ul>
<li>上角标n：导航(navigation)坐标系</li>
<li>下角标b：载体(body)坐标系</li>
</ul>
<p>下文均省略上下标</p>
<h2 id="矢量场与微分方程">矢量场与微分方程</h2>
<p>对于导航问题我们用如下微分方程描述 <span class="math inline">\(\dot
X(t)=F(t,X)\)</span></p>
<ul>
<li><span class="math inline">\(F\)</span> ：时变矢量场</li>
<li><span class="math inline">\(\dot X(t)\)</span>:
一个三元组的切向量，<span class="math inline">\(\dot X(t)=[\dot{R}(t,
X), \dot{P}(t, X), \dot{V}(t, X)] \in \mathfrak{s0}(3) \times
\mathbb{R}^{3} \times \mathbb{R}^{3}\)</span></li>
<li>在<span class="math inline">\(X\)</span>
处由所有切向量组成的空间表示为 <span class="math inline">\(T_XM\)</span>
，即<span class="math inline">\(F(t,X) \in T_XM\)</span></li>
<li><span class="math inline">\(\dot R=R[\omega ]_X\)</span></li>
</ul>
<p><span class="math display">\[
\dot{X}(t)=[\dot{R}(X, t), V(t), \dot{V}(X,
t)]=\left[R(t)\left[\omega^{b}(t)\right]_{\times}, V(t), g+R(t)
a^{b}(t)\right]
\]</span></p>
<h2 id="局部坐标">局部坐标</h2>
<p>基于流形空间的优化基于局部坐标的概念。当初始位姿为<span
class="math inline">\(R_0\)</span>，定义一个局部映射<span
class="math inline">\(\Phi _{R_0}(\theta)\)</span> 从局部坐标 <span
class="math inline">\(\theta\in \mathbb{R}^3\)</span> 映射到 <span
class="math inline">\(R_0\)</span> 的邻域： <span
class="math display">\[
\Phi_{R_{0}}(\theta)=R_{0} \exp \left([\theta]_{\times}\right)
\]</span> 局部坐标系<span class="math inline">\(\theta\)</span>
和切向量是同构的，定义<span class="math inline">\(\theta=\omega
t\)</span>,有 <span class="math display">\[
\left.\frac{d \Phi_{R_{0}}(\omega t)}{d t}\right|_{t=0}=\left.\frac{d
R_{0} \exp \left([\omega t]_{\times}\right)}{d
t}\right|_{t=0}=R_{0}[\omega]_{\times}
\]</span></p>
<ul>
<li>原文这里有一个笔误，反对称矩阵里面应该没有<span
class="math inline">\(t\)</span></li>
</ul>
<p>因此，三维向量<span
class="math inline">\(\omega\)</span>表示了在<span
class="math inline">\(SO(3)\)</span>流形上的前进方向，但是仅在<span
class="math inline">\(R_0\)</span>附近的局部坐标系上有效。</p>
<p>类似的，可以定义在<span
class="math inline">\(SE(3)\)</span>上的局部坐标 <span
class="math inline">\(\xi=[\omega t, v t] \in
\mathbb{R}^{6}\)</span>与其对应的映射函数 <span class="math display">\[
\Phi_{T_{0}}(\xi)=T_{0} \exp \hat{\xi}
\]</span></p>
<h2 id="局部坐标系映射的导数">局部坐标系映射的导数</h2>
<p>定义一个<span
class="math inline">\(3\times3\)</span>的雅克比矩阵模拟增量 <span
class="math inline">\(\delta\)</span> 对局部坐标系的影响。 <span
class="math display">\[
\Phi_{R_{0}}(\theta+\delta) \approx \Phi_{R_{0}}(\theta) \exp
\left([H(\theta)
\delta]_{\times}\right)=\Phi_{\Phi_{R_{0}}(\theta)}(H(\theta) \delta)
\]</span> 这个雅克比的计算仅仅依赖<span
class="math inline">\(\theta\)</span> <span class="math display">\[
H(\theta)=\sum_{k=0}^{\infty} \frac{(-1)^{k}}{(k+1)
!}[\theta]_{\times}^{k}
\]</span></p>
<h2 id="局部坐标中的数值积分">局部坐标中的数值积分</h2>
<p>对于问题<span class="math inline">\(\dot
R(t)=F(R,t)\)</span>,我们将其解建模为<span
class="math inline">\(R(t)=\Phi_{R_{0}}(\theta(t))\)</span></p>
<p>定义 <span class="math display">\[
\gamma(\delta)=R(t+\delta)=\Phi_{R_{0}}(\theta(t)+\dot{\theta}(t)
\delta) \approx \Phi_{R(t)}(H(\theta) \dot{\theta}(t) \delta)
\]</span></p>
<p>有 <span class="math display">\[
\dot{R}(t)=\left.\frac{d \gamma(\delta)}{d
\delta}\right|_{\delta=0}=\left.\frac{d \Phi_{R(t)}(H(\theta)
\dot{\theta}(t) \delta)}{d \delta}\right|_{\delta=0}=R[t][H(\theta)
\dot{\theta}(t)]_{\times}
\]</span></p>
<ul>
<li>关于这一节将数值积分内容是导数：数值积分用欧拉法用一阶导数近似迭代计算积分</li>
</ul>
<h2 id="收缩">收缩</h2>
<p><span class="math display">\[
\mathcal{R}_{X_{0}}(\zeta)=\left\{\Phi_{R_{0}}(\omega t), P_{0}+R_{0} v
t, V_{0}+R_{0} a t\right\}
\]</span></p>
<ul>
<li><span class="math inline">\(\zeta=[\omega t, v t, a t]\)</span></li>
<li>在<span class="math inline">\(X_0\)</span>处的切向量为<span
class="math inline">\(\left.\frac{d \mathcal{R}_{X_{0}}(\zeta)}{d
t}\right|_{t=0}=\left[R_{0}[\omega]_{\times}, R_{0} v, R_{0}
a\right]\)</span></li>
</ul>
<h2 id="基于局部坐标的积分">基于局部坐标的积分</h2>
<p>将状态表示为时间的函数 <span class="math display">\[
X(t)=\mathcal{R}_{X_{0}}(\zeta(t))=\left\{\Phi_{R_{0}}(\theta(t)),
P_{0}+R_{0} p(t), V_{0}+R_{0} v(t)\right\}
\]</span></p>
<p>定义一个轨迹函数<span
class="math inline">\(\gamma(\delta)\)</span>，自变量为时间的增量<span
class="math inline">\(\delta\)</span>,每一个<span
class="math inline">\(\delta\)</span>对应状态空间的条轨迹，<span
class="math inline">\(\gamma(\delta)\)</span>表示轨迹簇，并在<span
class="math inline">\(\delta=0\)</span>时通过X(t): <span
class="math display">\[
\gamma(\delta)=X(t+\delta)=\left\{\Phi_{R_{0}}(\theta(t)+\dot{\theta}(t)
\delta), P_{0}+R_{0}\{p(t)+\dot{p}(t) \delta\},
V_{0}+R_{0}\{v(t)+\dot{v}(t) \delta\}\right\}
\]</span></p>
<ul>
<li><span
class="math inline">\(\Phi_{R_{0}}(\theta(t+\delta))=\Phi_{R_{0}}(\theta(t)+\dot{\theta}(t)
\delta)\)</span>
<ul>
<li>这一步骤是用一阶导数近似，后面两项相同</li>
</ul></li>
</ul>
<p>导航状态的导数可以表示为</p>
<p><span class="math display">\[
\dot{X}(t)=\left.\frac{d \gamma(\delta)}{d
\delta}\right|_{\delta=0}=\left[R(t)\left[H(\theta)
\dot{\theta}(t)\right]_{\times}, R_{0} \dot{p}(t), R_{0}
\dot{v}(t)\right]
\]</span></p>
<h2 id="应用新的imu因子">应用：新的IMU因子</h2>
<p>铺垫了这么多 终于进入核心内容了</p>
<p>在Lupton 的论文(On-Manifold Preintegration for Real-Time
Visual–Inertial Odometry)中，当不知道导航状态<span
class="math inline">\(X_i\)</span>的状态时，无法对重力加速度进行补偿，因此吧速度拆成重力加速和比力两部分。</p>
<ul>
<li>注：IMU测的加速度实际上是比力(Specific force)--<span
class="math inline">\(f^b\)</span>
<ul>
<li><span class="math inline">\(f^b=R^b_n(a_{ii}^n-g^n)\)</span></li>
<li>我们真正需要的加速度是相对于惯性系的线性加速度 <span
class="math inline">\(a_{ii}^n=R^n_bf^b+g^n\)</span></li>
<li>要对重力进行补偿就需要知道载体坐标系相对导航坐标系的相对位姿</li>
</ul></li>
</ul>
<h3 id="对速度项做拆分">对速度项做拆分</h3>
<ul>
<li>Lupton 原文的预积分拆法表达</li>
</ul>
<p><span class="math display">\[
v_{t 2}^{n}=v_{t 1}^{n}+\int_{t 1}^{t 2}\left(R_{b
t}^{n}\left(f_{t}^{b}-b i a s_{f}^{o b s}\right)+g^{n}\right) d t=v_{t
1}^{n}+\int_{t 1}^{t 2} g^{n} d t+R_{b t 1}^{n} \int_{t 1}^{t
2}\left(R_{b t}^{b t 1}\left(f_{t}^{b}-b i a s_{f}^{o b s}\right)\right)
d t
\]</span></p>
<p>​ 把原文这个式子左右两边同乘<span
class="math inline">\(R^{bt1}_n\)</span>有 <span class="math display">\[
v_{t 2}^{bt 1}=v_{t 1}^{bt}+R^{bt1}_n\int_{t 1}^{t 2} g^{n} d t+ \int_{t
1}^{t 2}\left(R_{b t}^{b t 1}\left(f_{t}^{b}-b i a s_{f}^{o b
s}\right)\right) d t\tag{1}
\]</span></p>
<ul>
<li><p>本文档的表达 <span
class="math inline">\(v(t)=v_g(t)+v_a(t)\)</span></p>
<p>进一步的</p></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\dot{v}_{g}(t)=R_{i}^{T} g \\
&amp;\dot{v}_{a}(t)=R_{b}^{i}(t) a^{b}(t)
\end{aligned}
\]</span></p>
<p>​ 这里的公式和<span class="math inline">\((1)\)</span>中相同。</p>
<h3 id="对位置项做拆分">对位置项做拆分</h3>
<ul>
<li>Lupton原文的拆法</li>
</ul>
<p><span class="math display">\[
p_{t 2}^{n}=p_{t 1}^{n}+(t 2-t 1) v_{t 1}^{n}+\iint_{t 1}^{t
2}\left(R_{b t}^{n}\left(f_{t}^{b}-b i a s_{f}^{o b
s}\right)+g^{n}\right) d t^{2}= p_{t 1}^{n}+(t 2-t 1) v_{t
1}^{n}+\iint_{t 1}^{t 2} g^{n} d t^{2}+R_{b t 1}^{n} \iint_{t 1}^{t
2}\left(R_{b t}^{b t 1}\left(f_{t}^{b}-b i a s_{f}^{o b s}\right)\right)
d t^{2}
\]</span></p>
<p>​ 把原文这个式子左右两边同乘<span
class="math inline">\(R^{bt1}_n\)</span>有 <span class="math display">\[
p_{t 2}^{bt1}= p_{t 1}^{bt1}+(t 2-t 1) v_{t 1}^{bt1}+R_{n}^{bt1}\iint_{t
1}^{t 2} g^{n} d t^{2}+ \iint_{t 1}^{t 2}\left(R_{b t}^{b t
1}\left(f_{t}^{b}-b i a s_{f}^{o b s}\right)\right) d t^{2} \tag{2}
\]</span></p>
<ul>
<li>gtsam文档拆法表达</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;p(t)=p_{i}(t)+p_{g}(t)+p_{v}(t) \\
&amp;\dot{p}_{i}(t)=R_{i}^{T} V_{i} \\
&amp;\dot{p}_{g}(t)=v_{g}(t)=R_{i}^{T} g t \\
&amp;\dot{p}_{v}(t)=v_{a}(t)
\end{aligned}
\]</span></p>
<p>​ 这个式子和<span class="math inline">\((2)\)</span>本质相同。</p>
<p>总的来说，IMU预积分因子由一下三项组成 <span class="math display">\[
\begin{aligned}
\dot{\theta}(t) &amp;=H(\theta(t))^{-1} \omega^{b}(t) \\
\dot{p}_{v}(t) &amp;=v_{a}(t) \\
\dot{v}_{a}(t) &amp;=R_{b}^{i}(t) a^{b}(t)
\end{aligned}
\]</span> 从零开始，一直到时间<span
class="math inline">\(t_{ij}\)</span>，有<span
class="math inline">\(R_{b}^{i}(t)=\text{exp}([\theta(t)]_\times)\)</span>,用局部坐标向量表示为
<span class="math display">\[
\zeta\left(t_{i j}\right)=\left[\theta\left(t_{i j}\right), p\left(t_{i
j}\right), v\left(t_{i j}\right)\right]=\left[\theta\left(t_{i
j}\right), R_{i}^{T} V_{i} t_{i j}+R_{i}^{T} \frac{g t_{i
j}^{2}}{2}+p_{v}\left(t_{i j}\right), R_{i}^{T} g t_{i
j}+v_{a}\left(t_{i j}\right)\right]
\]</span> <span class="math inline">\(X_j\)</span>的导航状态可以表达为
<span class="math display">\[
X_{j}=\mathcal{R}_{X_{i}}\left(\zeta\left(t_{i
j}\right)\right)=\left\{\Phi_{R_{0}}\left(\theta\left(t_{i
j}\right)\right), P_{i}+V_{i} t_{i j}+\frac{g t_{i j}^{2}}{2}+R_{i}
p_{v}\left(t_{i j}\right), V_{i}+g t_{i j}+R_{i} v_{a}\left(t_{i
j}\right)\right\}
\]</span></p>
<h2 id="用欧拉法求解微分方程">用欧拉法求解微分方程</h2>
<p>欧拉法求解微分方程的原理就是用一阶导数近似来计算积分，有以下三个式子</p>
<p><span class="math display">\[
\begin{aligned}
\theta_{k+1}=\theta_{k}+\dot{\theta}\left(t_{k}\right) \Delta_{t}
&amp;=\theta_{k}+H\left(\theta_{k}\right)^{-1} \omega_{k}^{b} \Delta_{t}
\\
p_{k+1}=p_{k}+\dot{p}_{v}\left(t_{k}\right) \Delta_{t} &amp;=p_{k}+v_{k}
\Delta_{t} \\
v_{k+1}=v_{k}+\dot{v}_{a}\left(t_{k}\right) \Delta_{t} &amp;=v_{k}+\exp
\left(\left[\theta_{k}\right]_{\times}\right) a_{k}^{b} \Delta_{t}
\end{aligned}
\]</span> 其中<span class="math inline">\(\theta_{k} \triangleq
\theta\left(t_{k}\right), p_{k} \triangleq p_{v}\left(t_{k}\right),
v_{k} \triangleq v_{a}\left(t_{k}\right)\)</span></p>
<p>进一步提高位置的精度，引入二阶导数计算(加速度)</p>
<p><span class="math display">\[
\begin{aligned}
\theta_{k+1} &amp;=\theta_{k}+H\left(\theta_{k}\right)^{-1}
\omega_{k}^{b} \Delta_{t} \\
p_{k+1} &amp;=p_{k}+v_{k} \Delta_{t}+R_{k} a_{k}^{b}
\frac{\Delta_{t}^{2}}{2} \\
v_{k+1} &amp;=v_{k}+R_{k} a_{k}^{b} \Delta_{t}
\end{aligned}
\]</span></p>
<h2 id="噪声协方差矩阵传递">噪声(协方差矩阵)传递</h2>
<p>定义<span class="math inline">\(t_k\)</span>时刻的导航状态为<span
class="math inline">\(\zeta_k=[\theta_k,p_k,v_k]\)</span>， <span
class="math display">\[
\zeta_{k+1}=f\left(\zeta_{k}, a_{k}^{b}, \omega_{k}^{b}\right)
\]</span> 噪声的传递可以表达为 <span class="math display">\[
\Sigma_{k+1}=A_{k} \Sigma_{k} A_{k}^{T}+B_{k}\Sigma_{\eta}^{a d}
B_{k}+C_{k} \Sigma_{\eta}^{g d} C_{k}
\]</span></p>
<ul>
<li><p><span class="math inline">\(\Sigma_{k+1}\)</span>: <span
class="math inline">\(t_{k+1}\)</span>时刻的协方差矩阵，<span
class="math inline">\(9\times9\)</span>大小</p></li>
<li><p><span class="math inline">\(\Sigma_{k}\)</span>: <span
class="math inline">\(t_{k}\)</span>时刻的协方差矩阵，<span
class="math inline">\(9\times9\)</span>矩阵</p></li>
<li><p><span class="math inline">\(\Sigma_{\eta}^{a
d}\)</span>测量加速度引入的噪声，<span
class="math inline">\(3\times3\)</span>矩阵</p></li>
<li><p><span class="math inline">\(\Sigma_{\eta}^{g
d}\)</span>测量角速度引入的噪声，<span
class="math inline">\(3\times3\)</span>矩阵</p></li>
<li><p><span class="math display">\[
A_{k} \approx\left[\begin{array}{ccc}
I_{3 \times 3}-\frac{\Delta_{t}}{2}\left[\omega_{k}^{b}\right]_{\times}
&amp;0 &amp; 0\\
R_{k}\left[-a_{k}^{b}\right]_{\times} H\left(\theta_{k}\right)
\frac{\Delta_{t}}{2} &amp; I_{3 \times 3} &amp; I_{3 \times 3}
\Delta_{t} \\
R_{k}\left[-a_{k}^{b}\right]_{\times} H\left(\theta_{k}\right)
\Delta_{t} &amp;0 &amp; I_{3 \times 3}
\end{array}\right]
\]</span></p></li>
<li><p><span class="math display">\[
B_{k}=\left[\begin{array}{c}
0_{3 \times 3} \\
R_{k} \frac{\Delta_{t}}{2} \\
R_{k} \Delta_{t}
\end{array}\right], \quad C_{k}=\left[\begin{array}{c}
H\left(\theta_{k}\right)^{-1} \Delta_{t} \\
0_{3 \times 3} \\
0_{3 \times 3}
\end{array}\right]
\]</span></p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/21/gtsam%E5%85%B3%E4%BA%8Eimu%E9%A2%84%E7%A7%AF%E5%88%86%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="曾圣尧">
      <meta itemprop="description" content="好记性不如烂笔头">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南柯一梦">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/21/gtsam%E5%85%B3%E4%BA%8Eimu%E9%A2%84%E7%A7%AF%E5%88%86%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">gtsam关于imu预积分实现探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-21 19:29:06" itemprop="dateCreated datePublished" datetime="2022-04-21T19:29:06+08:00">2022-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-21 18:11:03" itemprop="dateModified" datetime="2024-01-21T18:11:03+08:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lidar-SLAM/" itemprop="url" rel="index"><span itemprop="name">Lidar SLAM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gtsam关于imu预积分实现探究">gtsam关于imu预积分实现探究</h1>
<h2 id="资料">资料</h2>
<p>gtsam官网关于IMU预积分的资料介绍了gtsam预积分基于以下论文实现</p>
<blockquote>
<p>Todd Lupton and Salah Sukkarieh, “Visual-Inertial-Aided Navigation
for High-Dynamic Motion in Built Environments Without Initial
Conditions”, TRO, 28(1):61-76, 2012.</p>
</blockquote>
<p>同时基于流形空间进行了优化，基于以下两篇论文</p>
<blockquote>
<p>Luca Carlone, Zsolt Kira, Chris Beall, Vadim Indelman, and Frank
Dellaert, “Eliminating conditionally independent sets in factor graphs:
a unifying perspective based on smart factors”, Int. Conf. on Robotics
and Automation (ICRA), 2014.</p>
</blockquote>
<blockquote>
<p>Christian Forster, Luca Carlone, Frank Dellaert, and Davide
Scaramuzza, “IMU Preintegration on Manifold for Efficient
Visual-Inertial Maximum-a-Posteriori Estimation”, Robotics: Science and
Systems (RSS), 2015.</p>
</blockquote>
<h2 id="代码分析">代码分析</h2>
<h3 id="从main文件着手">从main文件着手</h3>
<p>我们从gtsam给的例程代码入手，<code>ImuFactorsExample.cpp</code>文件描述了IMU预积分GPS进行导航的代码。</p>
<p>打开输入输出文件以后，首先是基础操作初始化一个非线性因子图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add all prior factors (pose, velocity, bias) to the graph.</span></span><br><span class="line">NonlinearFactorGraph *graph = <span class="keyword">new</span> <span class="built_in">NonlinearFactorGraph</span>();</span><br><span class="line">graph-&gt;<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Pose3&gt;(<span class="built_in">X</span>(correction_count), prior_pose, pose_noise_model));</span><br><span class="line">graph-&gt;<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Vector3&gt;(<span class="built_in">V</span>(correction_count), prior_velocity,velocity_noise_model));</span><br><span class="line">graph-&gt;<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;imuBias::ConstantBias&gt;(<span class="built_in">B</span>(correction_count), prior_imu_bias,bias_noise_model));</span><br></pre></td></tr></table></figure>
<p>例程提供了两种预积分方式<code>PreintegratedCombinedMeasurements</code>和<code>PreintegratedImuMeasurements</code>,我们按<code>PreintegratedImuMeasurements</code>进行分析。
在初始化一个IMU预积分量之前首先初始化了预积分的基础参数，各种协方差</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boost::shared_ptr&lt;PreintegratedCombinedMeasurements::Params&gt; p = PreintegratedCombinedMeasurements::Params::<span class="built_in">MakeSharedD</span>(<span class="number">0.0</span>);</span><br><span class="line"><span class="comment">// PreintegrationBase params:</span></span><br><span class="line">p-&gt;accelerometerCovariance = measured_acc_cov; <span class="comment">// acc white noise in continuous</span></span><br><span class="line">p-&gt;integrationCovariance = integration_error_cov; <span class="comment">// integration uncertainty continuous</span></span><br><span class="line"><span class="comment">// should be using 2nd order integration</span></span><br><span class="line"><span class="comment">// PreintegratedRotation params:</span></span><br><span class="line">p-&gt;gyroscopeCovariance = measured_omega_cov; <span class="comment">// gyro white noise in continuous</span></span><br><span class="line"><span class="comment">// PreintegrationCombinedMeasurements params:</span></span><br><span class="line">p-&gt;biasAccCovariance = bias_acc_cov; <span class="comment">// acc bias in continuous</span></span><br><span class="line">p-&gt;biasOmegaCovariance = bias_omega_cov; <span class="comment">// gyro bias in continuous</span></span><br><span class="line">p-&gt;biasAccOmegaInt = bias_acc_omega_int;</span><br></pre></td></tr></table></figure>
<p>初始化一个imu预积分对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imu_preintegrated_ = <span class="keyword">new</span> <span class="built_in">PreintegratedImuMeasurements</span>(p, prior_imu_bias);</span><br></pre></td></tr></table></figure>
<p>读取数据，如果是imu数据，就进行预积分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span>) &#123; <span class="comment">// IMU measurement</span></span><br><span class="line">  Eigen::Matrix&lt;<span class="type">double</span>,<span class="number">6</span>,<span class="number">1</span>&gt; imu = Eigen::Matrix&lt;<span class="type">double</span>,<span class="number">6</span>,<span class="number">1</span>&gt;::<span class="built_in">Zero</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">getlie</span>(file, value, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="built_in">imu</span>(i) = <span class="built_in">atof</span>(value.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">getline</span>(file, value, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="built_in">imu</span>(<span class="number">5</span>) = <span class="built_in">atof</span>(value.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adding the IMU preintegration.</span></span><br><span class="line">  imu_preintegrated_-&gt;<span class="built_in">integrateMeasurement</span>(imu.<span class="built_in">head</span>&lt;<span class="number">3</span>&gt;(), imu.<span class="built_in">tail</span>&lt;<span class="number">3</span>&gt;(), dt);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>追踪<code>imu_preintegrated_-&gt;integrateMeasurement(imu.head&lt;3&gt;(), imu.tail&lt;3&gt;(), dt)</code>,可以发现函数定义为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreintegrationBase::integrateMeasurement</span><span class="params">(<span class="type">const</span> Vector3&amp; measuredAcc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Vector3&amp; measuredOmega, <span class="type">double</span> dt)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// NOTE(frank): integrateMeasurement always needs to compute the derivatives,</span></span><br><span class="line">  <span class="comment">// even when not of interest to the caller. Provide scratch space here.</span></span><br><span class="line">  Matrix9 A;</span><br><span class="line">  Matrix93 B, C;</span><br><span class="line">  <span class="built_in">update</span>(measuredAcc, measuredOmega, dt, &amp;A, &amp;B, &amp;C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心为<code>update(measuredAcc, measuredOmega, dt, &amp;A, &amp;B, &amp;C);</code>，关于这个<code>updata</code>函数gtsam有两种实现，<code>TangentPreintegration::update</code>和<code>ManifoldPreintegration::update</code>。即基于切空间和基于流形空间的实现。选用哪种实现取决于gtsam编译安装时<code>GTSAM_TANGENT_PREINTEGRATION.</code>为<code>ON</code>还是<code>OFF</code>。默认为切空间；流形空间的实现基于RSS2015的文献实现，切空间的实现在gtsam自带的文档有介绍。这里我们以默认的切空间分析。</p>
<h3 id="切空间的更新函数实现">切空间的更新函数实现</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TangentPreintegration::update</span><span class="params">(<span class="type">const</span> Vector3&amp; measuredAcc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Vector3&amp; measuredOmega, <span class="type">const</span> <span class="type">double</span> dt, Matrix9* A, Matrix93* B,</span></span></span><br><span class="line"><span class="params"><span class="function">    Matrix93* C)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Correct for bias in the sensor frame</span></span><br><span class="line">  Vector3 acc = biasHat_.<span class="built_in">correctAccelerometer</span>(measuredAcc);</span><br><span class="line">  Vector3 omega = biasHat_.<span class="built_in">correctGyroscope</span>(measuredOmega);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Possibly correct for sensor pose</span></span><br><span class="line">  Matrix3 D_correctedAcc_acc, D_correctedAcc_omega, D_correctedOmega_omega;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">p</span>().body_P_sensor)</span><br><span class="line">    boost::<span class="built_in">tie</span>(acc, omega) = <span class="built_in">correctMeasurementsBySensorPose</span>(acc, omega,</span><br><span class="line">        D_correctedAcc_acc, D_correctedAcc_omega, D_correctedOmega_omega);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do update</span></span><br><span class="line">  deltaTij_ += dt;</span><br><span class="line">  preintegrated_ = <span class="built_in">UpdatePreintegrated</span>(acc, omega, dt, preintegrated_, A, B, C);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">p</span>().body_P_sensor) &#123;</span><br><span class="line">    <span class="comment">// More complicated derivatives in case of non-trivial sensor pose</span></span><br><span class="line">    *C *= D_correctedOmega_omega;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">p</span>().body_P_sensor-&gt;<span class="built_in">translation</span>().<span class="built_in">isZero</span>())</span><br><span class="line">      *C += *B * D_correctedAcc_omega;</span><br><span class="line">    *B *= D_correctedAcc_acc; <span class="comment">// NOTE(frank): needs to be last</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new_H_biasAcc = new_H_old * old_H_biasAcc + new_H_acc * acc_H_biasAcc</span></span><br><span class="line">  <span class="comment">// where acc_H_biasAcc = -I_3x3, hence</span></span><br><span class="line">  <span class="comment">// new_H_biasAcc = new_H_old * old_H_biasAcc - new_H_acc</span></span><br><span class="line">  preintegrated_H_biasAcc_ = (*A) * preintegrated_H_biasAcc_ - (*B);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new_H_biasOmega = new_H_old * old_H_biasOmega + new_H_omega * omega_H_biasOmega</span></span><br><span class="line">  <span class="comment">// where omega_H_biasOmega = -I_3x3, hence</span></span><br><span class="line">  <span class="comment">// new_H_biasOmega = new_H_old * old_H_biasOmega - new_H_omega</span></span><br><span class="line">  preintegrated_H_biasOmega_ = (*A) * preintegrated_H_biasOmega_ - (*C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，首先对加速度和角速度进行修正，减去当前其偏置值(bias),得到修正后的加速度角速度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 acc = biasHat_.<span class="built_in">correctAccelerometer</span>(measuredAcc);</span><br><span class="line">Vector3 omega = biasHat_.<span class="built_in">correctGyroscope</span>(measuredOmega);</span><br></pre></td></tr></table></figure>
<h4
id="body坐标系和imu坐标系之间的转换">body坐标系和imu坐标系之间的转换</h4>
<p>默认情况下imu坐标系和body坐标系是一个坐标系，也可以设置不是一个坐标系。
通过在初始化时设置<code>p-&gt;body_P_sensor</code>的值确定imu坐标系到body坐标系的转换矩阵。如果设置了两个坐标系之间的转换关系，那么需要将imu测量的imu坐标系的加速度和角速度转换为body坐标系的加速度角速度。在<code>updata()</code>函数的中的这几行代码就是执行这一操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">p</span>().body_P_sensor)</span><br><span class="line">boost::<span class="built_in">tie</span>(acc, omega) = <span class="built_in">correctMeasurementsBySensorPose</span>(acc, omega,</span><br><span class="line">    D_correctedAcc_acc, D_correctedAcc_omega, D_correctedOmega_omega);</span><br></pre></td></tr></table></figure>
<h5 id="代码">代码</h5>
<p>追踪<code>correctMeasurementsBySensorPose()</code>函数我们可以看到这个函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;Vector3, Vector3&gt; <span class="title">PreintegrationBase::correctMeasurementsBySensorPose</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Vector3&amp; unbiasedAcc, <span class="type">const</span> Vector3&amp; unbiasedOmega,</span></span></span><br><span class="line"><span class="params"><span class="function">    OptionalJacobian&lt;<span class="number">3</span>, <span class="number">3</span>&gt; correctedAcc_H_unbiasedAcc,</span></span></span><br><span class="line"><span class="params"><span class="function">    OptionalJacobian&lt;<span class="number">3</span>, <span class="number">3</span>&gt; correctedAcc_H_unbiasedOmega,</span></span></span><br><span class="line"><span class="params"><span class="function">    OptionalJacobian&lt;<span class="number">3</span>, <span class="number">3</span>&gt; correctedOmega_H_unbiasedOmega)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">p</span>().body_P_sensor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compensate for sensor-body displacement if needed: we express the quantities</span></span><br><span class="line">  <span class="comment">// (originally in the IMU frame) into the body frame</span></span><br><span class="line">  <span class="comment">// Equations below assume the &quot;body&quot; frame is the CG</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get sensor to body rotation matrix</span></span><br><span class="line">  <span class="type">const</span> Matrix3 bRs = <span class="built_in">p</span>().body_P_sensor-&gt;<span class="built_in">rotation</span>().<span class="built_in">matrix</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert angular velocity and acceleration from sensor to body frame</span></span><br><span class="line">  Vector3 correctedAcc = bRs * unbiasedAcc;</span><br><span class="line">  <span class="type">const</span> Vector3 correctedOmega = bRs * unbiasedOmega;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jacobians</span></span><br><span class="line">  <span class="keyword">if</span> (correctedAcc_H_unbiasedAcc) *correctedAcc_H_unbiasedAcc = bRs;</span><br><span class="line">  <span class="keyword">if</span> (correctedAcc_H_unbiasedOmega) *correctedAcc_H_unbiasedOmega = Z_3x3;</span><br><span class="line">  <span class="keyword">if</span> (correctedOmega_H_unbiasedOmega) *correctedOmega_H_unbiasedOmega = bRs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Centrifugal acceleration</span></span><br><span class="line">  <span class="type">const</span> Vector3 b_arm = <span class="built_in">p</span>().body_P_sensor-&gt;<span class="built_in">translation</span>();</span><br><span class="line">  <span class="keyword">if</span> (!b_arm.<span class="built_in">isZero</span>()) &#123;</span><br><span class="line">    <span class="comment">// Subtract out the the centripetal acceleration from the unbiased one</span></span><br><span class="line">    <span class="comment">// to get linear acceleration vector in the body frame:</span></span><br><span class="line">    <span class="type">const</span> Matrix3 body_Omega_body = <span class="built_in">skewSymmetric</span>(correctedOmega);</span><br><span class="line">    <span class="type">const</span> Vector3 b_velocity_bs = body_Omega_body * b_arm; <span class="comment">// magnitude: omega * arm</span></span><br><span class="line">    correctedAcc -= body_Omega_body * b_velocity_bs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update derivative: centrifugal causes the correlation between acc and omega!!!</span></span><br><span class="line">    <span class="keyword">if</span> (correctedAcc_H_unbiasedOmega) &#123;</span><br><span class="line">      <span class="type">double</span> wdp = correctedOmega.<span class="built_in">dot</span>(b_arm);</span><br><span class="line">      <span class="type">const</span> Matrix3 diag_wdp = Vector3::<span class="built_in">Constant</span>(wdp).<span class="built_in">asDiagonal</span>();</span><br><span class="line">      *correctedAcc_H_unbiasedOmega = -( diag_wdp</span><br><span class="line">          + correctedOmega * b_arm.<span class="built_in">transpose</span>()) * bRs.<span class="built_in">matrix</span>()</span><br><span class="line">          + <span class="number">2</span> * b_arm * unbiasedOmega.<span class="built_in">transpose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_pair</span>(correctedAcc, correctedOmega);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="公式化表达">公式化表达</h5>
<p>速度加速度从sensor(IMU)坐标系转换到body坐标系 <span
class="math display">\[
\omega^\prime=R_s^b \omega
\]</span> <span class="math display">\[
a^\prime=R_s^b a
\]</span> 离心加速度 <span class="math display">\[
v_{bs}^b=\omega^\prime\times p
\]</span> <span class="math display">\[
a_c=\omega^\prime\times v_{bs}^b
\]</span> 将离心加速度从加速中去掉 <span class="math display">\[
a\prime=a\prime-a_c
\]</span></p>
<h4 id="更新预积分量">更新预积分量</h4>
<p>下面是重头戏，更新预积分量了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preintegrated_ = <span class="built_in">UpdatePreintegrated</span>(acc, omega, dt, preintegrated_, A, B, C);</span><br></pre></td></tr></table></figure>
<p>从函数调用可以看到，函数接收7个值，刚才修正过后的加速度，角速度，时间间隔，上一次运算结束保存的预积分量，A,B,C。
追踪这个函数，我们先看一下整体实现。</p>
<h5 id="代码-1">代码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector9 <span class="title">TangentPreintegration::UpdatePreintegrated</span><span class="params">(<span class="type">const</span> Vector3&amp; a_body,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Vector3&amp; w_body, <span class="type">double</span> dt, <span class="type">const</span> Vector9&amp; preintegrated,</span></span></span><br><span class="line"><span class="params"><span class="function">    OptionalJacobian&lt;<span class="number">9</span>, <span class="number">9</span>&gt; A, OptionalJacobian&lt;<span class="number">9</span>, <span class="number">3</span>&gt; B,</span></span></span><br><span class="line"><span class="params"><span class="function">    OptionalJacobian&lt;<span class="number">9</span>, <span class="number">3</span>&gt; C)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> theta = preintegrated.<span class="built_in">segment</span>&lt;<span class="number">3</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> position = preintegrated.<span class="built_in">segment</span>&lt;<span class="number">3</span>&gt;(<span class="number">3</span>);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> velocity = preintegrated.<span class="built_in">segment</span>&lt;<span class="number">3</span>&gt;(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This functor allows for saving computation when exponential map and its</span></span><br><span class="line">  <span class="comment">// derivatives are needed at the same location in so&lt;3&gt;</span></span><br><span class="line">  <span class="function">so3::DexpFunctor <span class="title">local</span><span class="params">(theta)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate exact mean propagation</span></span><br><span class="line">  Matrix3 w_tangent_H_theta, invH;</span><br><span class="line">  <span class="type">const</span> Vector3 w_tangent = <span class="comment">// angular velocity mapped back to tangent space</span></span><br><span class="line">      local.<span class="built_in">applyInvDexp</span>(w_body, A ? &amp;w_tangent_H_theta : <span class="number">0</span>, C ? &amp;invH : <span class="number">0</span>);</span><br><span class="line">  <span class="type">const</span> SO3 R = local.<span class="built_in">expmap</span>();</span><br><span class="line">  <span class="type">const</span> Vector3 a_nav = R * a_body;</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> dt22 = <span class="number">0.5</span> * dt * dt;</span><br><span class="line"></span><br><span class="line">  Vector9 preintegratedPlus;</span><br><span class="line">  preintegratedPlus &lt;&lt; <span class="comment">// new preintegrated vector:</span></span><br><span class="line">      theta + w_tangent * dt, <span class="comment">// theta</span></span><br><span class="line">  position + velocity * dt + a_nav * dt22, <span class="comment">// position</span></span><br><span class="line">  velocity + a_nav * dt; <span class="comment">// velocity</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (A) &#123;</span><br><span class="line">    <span class="comment">// Exact derivative of R*a with respect to theta:</span></span><br><span class="line">    <span class="type">const</span> Matrix3 a_nav_H_theta = R * <span class="built_in">skewSymmetric</span>(-a_body) * local.<span class="built_in">dexp</span>();</span><br><span class="line"></span><br><span class="line">    A-&gt;<span class="built_in">setIdentity</span>();</span><br><span class="line">    A-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>).<span class="built_in">noalias</span>() += w_tangent_H_theta * dt; <span class="comment">// theta</span></span><br><span class="line">    A-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) = a_nav_H_theta * dt22; <span class="comment">// position wrpt theta...</span></span><br><span class="line">    A-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">6</span>) = I_3x3 * dt; <span class="comment">// .. and velocity</span></span><br><span class="line">    A-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) = a_nav_H_theta * dt; <span class="comment">// velocity wrpt theta</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (B) &#123;</span><br><span class="line">    B-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = Z_3x3;</span><br><span class="line">    B-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) = R * dt22;</span><br><span class="line">    B-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) = R * dt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (C) &#123;</span><br><span class="line">    C-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = invH * dt;</span><br><span class="line">    C-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) = Z_3x3;</span><br><span class="line">    C-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) = Z_3x3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> preintegratedPlus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分析">分析</h5>
<p>首先可以看到，预积分量的代码表达 为一个九维向量：<span
class="math inline">\(preintegrated=[\theta,x,v]\)</span>。</p>
<p>接着，这里实例化了一套局部坐标系，关于这个local，gtsam的文档有详细介绍。参见：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37656107/article/details/124324965?spm=1001.2014.3001.5501">a
new imu factor</a></p>
<p>然后是一个重要操作，借助局部坐标把角速度的切向量求取回来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Vector3 w_tangent = <span class="comment">// angular velocity mapped back to tangent space</span></span><br><span class="line">    local.<span class="built_in">applyInvDexp</span>(w_body, A ? &amp;w_tangent_H_theta : <span class="number">0</span>, C ? &amp;invH : <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h6 id="切向量求取">切向量求取</h6>
<p>让我们跳转进去，看看这个函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3 <span class="title">DexpFunctor::applyInvDexp</span><span class="params">(<span class="type">const</span> Vector3&amp; v, OptionalJacobian&lt;<span class="number">3</span>, <span class="number">3</span>&gt; H1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  OptionalJacobian&lt;<span class="number">3</span>, <span class="number">3</span>&gt; H2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Matrix3 invDexp = dexp_.<span class="built_in">inverse</span>();</span><br><span class="line">  <span class="type">const</span> Vector3 c = invDexp * v;</span><br><span class="line">  <span class="keyword">if</span> (H1) &#123;</span><br><span class="line">    Matrix3 D_dexpv_omega;</span><br><span class="line">    <span class="built_in">applyDexp</span>(c, D_dexpv_omega);  <span class="comment">// get derivative H of forward mapping</span></span><br><span class="line">    *H1 = -invDexp* D_dexpv_omega;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (H2) *H2 = invDexp;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里的变量对应论文的公式表达</p>
<ul>
<li><code>dexp_</code>: <span class="math inline">\(H(\theta
)\)</span>，这个量是在初始化局部坐标系的时候就求好了的</li>
<li><code>invDexp</code>：<span class="math inline">\(H(\theta
)^{-1}\)</span>,
这个量就是借助<code>dexp_</code>这个矩阵用Eigen直接矩阵求逆得到的</li>
<li><code>v</code>: <span class="math inline">\(\omega_k^b\)</span></li>
<li><code>D_dexpv_omega</code>：用来更新噪声传播</li>
<li>总的来看这个函数返回值赋值给切向量可以表达为 <span
class="math inline">\(\text{w\_tangent}=-H(\theta
)^{-1}\omega_k^b\)</span></li>
</ul>
<p>这里特别感兴趣 <span class="math inline">\(H(\theta
)\)</span>这个量的实现，找到local坐标系里面对其的求取:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DexpFunctor::<span class="built_in">DexpFunctor</span>(<span class="type">const</span> Vector3&amp; omega, <span class="type">bool</span> nearZeroApprox)</span><br><span class="line">    : <span class="built_in">ExpmapFunctor</span>(omega, nearZeroApprox), <span class="built_in">omega</span>(omega) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nearZero)</span><br><span class="line">    dexp_ = I_3x3 - <span class="number">0.5</span> * W;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    a = one_minus_cos / theta;</span><br><span class="line">    b = <span class="number">1.0</span> - sin_theta / theta;</span><br><span class="line">    dexp_ = I_3x3 - a * K + b * KK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>W</code>: <span
class="math inline">\([\omega]_{\times}\)</span></li>
<li><code>theta</code>: <span
class="math inline">\(||\omega||\)</span></li>
<li><code>one_minus_cos</code>: <span
class="math inline">\(1-cos||\omega||\)</span></li>
<li><code>K</code>: <span
class="math inline">\(\frac{[w]_\times}{||\omega||}\)</span></li>
<li><code>KK</code>: <span
class="math inline">\({\frac{[w]_\times^2}{\||\omega||^2}}\)</span></li>
</ul>
<p>分析可以看到其计算方式为 <span class="math display">\[
H(\omega)=
\begin{cases}
I-\frac{1}{2}[\omega]_\times&amp; ||\omega|| \approx 0\\
I-\frac{\left(1-\cos
||\omega||)\right[\omega]_\times}{||\omega||^2}+\left(1-\frac{\sin
||\omega||}{||\omega||}\right)\left(\frac{[\omega]_\times}{||\omega||}\right)^2&amp;
\text{others}
\end{cases}
\]</span></p>
<p>本质就是以右扰动定义的雅克比，参见下文献中的公式10.86的<span
class="math inline">\(J_r(x)\)</span>，此外注意这里的<span
class="math inline">\(\omega\)</span>是初始化local的时候传入的<span
class="math inline">\(\theta\)</span>，不是测量的角速度<span
class="math inline">\(\omega\)</span> &gt;Gregory S. Chirikjian.
“Stochastic Models, Information Theory, and Lie Groups, Volume 2”
(2012).</p>
<p>更新预积分的测量值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preintegratedPlus &lt;&lt; theta + w_tangent * dt, position + velocity * dt + a_nav * dt22, velocity + a_nav * dt;  </span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{aligned}
\theta_{k+1} &amp;=\theta_{k}+H\left(\theta_{k}\right)^{-1}
\omega_{k}^{b} \Delta_{t} \\
p_{k+1} &amp;=p_{k}+v_{k} \Delta_{t}+R_{k} a_{k}^{b}
\frac{\Delta_{t}^{2}}{2} \\
v_{k+1} &amp;=v_{k}+R_{k} a_{k}^{b} \Delta_{t}
\end{aligned}
\]</span></p>
<p>最后，针对误差传递 <span class="math inline">\(\Sigma_{k+1}=A_{k}
\Sigma_{k} A_{k}^{T}+B_{k}\Sigma_{\eta}^{a d} B_{k}+C_{k}
\Sigma_{\eta}^{g d} C_{k}\)</span>，更新A，B，C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">  <span class="comment">// Exact derivative of R*a with respect to theta:</span></span><br><span class="line">  <span class="type">const</span> Matrix3 a_nav_H_theta = R * <span class="built_in">skewSymmetric</span>(-a_body) * local.<span class="built_in">dexp</span>();</span><br><span class="line"></span><br><span class="line">  A-&gt;<span class="built_in">setIdentity</span>();</span><br><span class="line">  A-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>).<span class="built_in">noalias</span>() += w_tangent_H_theta * dt; <span class="comment">// theta</span></span><br><span class="line">  A-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) = a_nav_H_theta * dt22; <span class="comment">// position wrpt theta...</span></span><br><span class="line">  A-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">6</span>) = I_3x3 * dt; <span class="comment">// .. and velocity</span></span><br><span class="line">  A-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) = a_nav_H_theta * dt; <span class="comment">// velocity wrpt theta</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (B) &#123;</span><br><span class="line">  B-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = Z_3x3;</span><br><span class="line">  B-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) = R * dt22;</span><br><span class="line">  B-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) = R * dt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (C) &#123;</span><br><span class="line">  C-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">0</span>, <span class="number">0</span>) = invH * dt;</span><br><span class="line">  C-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">3</span>, <span class="number">0</span>) = Z_3x3;</span><br><span class="line">  C-&gt;<span class="built_in">block</span>&lt;<span class="number">3</span>, <span class="number">3</span>&gt;(<span class="number">6</span>, <span class="number">0</span>) = Z_3x3;</span><br></pre></td></tr></table></figure>
<p>对应公式 <span class="math display">\[
  A_{k} \approx\left[\begin{array}{ccc}
  I_{3 \times
3}-\frac{\Delta_{t}}{2}\left[\omega_{k}^{b}\right]_{\times} &amp;0 &amp;
0\\
  R_{k}\left[-a_{k}^{b}\right]_{\times} H\left(\theta_{k}\right)
\frac{\Delta_{t}}{2} &amp; I_{3 \times 3} &amp; I_{3 \times 3}
\Delta_{t} \\
  R_{k}\left[-a_{k}^{b}\right]_{\times} H\left(\theta_{k}\right)
\Delta_{t} &amp;0 &amp; I_{3 \times 3}
  \end{array}\right]
  \]</span></p>
<p><span class="math display">\[
  B_{k}=\left[\begin{array}{c}
  0_{3 \times 3} \\
  R_{k} \frac{\Delta_{t}}{2} \\
  R_{k} \Delta_{t}
  \end{array}\right], \quad C_{k}=\left[\begin{array}{c}
  H\left(\theta_{k}\right)^{-1} \Delta_{t} \\
  0_{3 \times 3} \\
  0_{3 \times 3}
  \end{array}\right]
  \]</span></p>
<h3 id="回到main函数">回到main函数</h3>
<p>当读取到GPS的数据的时候，首先将两帧GPS数据之间的IMU预积分量添加到图优化的框架里面去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PreintegratedImuMeasurements *preint_imu = <span class="built_in">dynamic_cast</span>&lt;PreintegratedImuMeasurements*&gt;(imu_preintegrated_);</span><br><span class="line"><span class="function">ImuFactor <span class="title">imu_factor</span><span class="params">(X(correction_count<span class="number">-1</span>), V(correction_count<span class="number">-1</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                      X(correction_count  ), V(correction_count  ),</span></span></span><br><span class="line"><span class="params"><span class="function">                      B(correction_count<span class="number">-1</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                      *preint_imu)</span></span>;</span><br><span class="line">graph-&gt;<span class="built_in">add</span>(imu_factor);</span><br></pre></td></tr></table></figure>
<p>此外，针对两帧GPS数据之间的IMU bias的变化量添加一个约束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">imuBias::ConstantBias <span class="title">zero_bias</span><span class="params">(Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">graph-&gt;<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;imuBias::ConstantBias&gt;(<span class="built_in">B</span>(correction_count<span class="number">-1</span>),</span><br><span class="line">                                                <span class="built_in">B</span>(correction_count  ),</span><br><span class="line">                                                zero_bias, bias_noise_model));</span><br></pre></td></tr></table></figure>
<p>添加gps测量约束，然后对图进行优化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/01/cartographer%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="曾圣尧">
      <meta itemprop="description" content="好记性不如烂笔头">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南柯一梦">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/cartographer%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">cartographer阅读笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 19:29:06" itemprop="dateCreated datePublished" datetime="2021-06-01T19:29:06+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-21 18:11:05" itemprop="dateModified" datetime="2024-01-21T18:11:05+08:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lidar-SLAM/" itemprop="url" rel="index"><span itemprop="name">Lidar SLAM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="cartographer阅读笔记">cartographer阅读笔记</h1>
<h2 id="一些不熟悉的c知识">一些不熟悉的C++知识</h2>
<h3 id="stdmove">std::move()</h3>
<p><code>std::move</code> 右值引用</p>
<p>左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象</p>
<p>在C++11之前，右值是不能引的，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = <span class="number">1</span>;			<span class="comment">// error: 非常量的引用必须为左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">1</span>;	<span class="comment">// 我们最多只能用常量引用来绑定一个右值</span></span><br></pre></td></tr></table></figure>
<p>在C++11中我们可以引用右值，使用&amp;&amp;实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>右值引用的目的</p>
<pre><code>  　1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
  　2. 能够更简洁明确地定义泛型函数。</code></pre>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</span><br><span class="line">    <span class="comment">//调用常规的拷贝构造函数，新建字符数组，拷贝数据</span></span><br><span class="line">    v.push_back(str);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After copy, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//调用移动构造函数，掏空str，掏空后，最好不要使用str</span></span><br><span class="line">    v.push_back(<span class="built_in">std</span>::move(str));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After move, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The contents of the vector are \&quot;&quot;</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\&quot;, \&quot;&quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">After</span> <span class="keyword">copy</span>, str <span class="keyword">is</span> &quot;Hello&quot;</span><br><span class="line"><span class="keyword">After</span> <span class="keyword">move</span>, str <span class="keyword">is</span> &quot;&quot;</span><br><span class="line">The contents <span class="keyword">of</span> the vector are &quot;Hello&quot;, &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<h3 id="stdunique_ptr">std::unique_ptr</h3>
<p>无法复制，只能移动的智能指针</p>
<h3 id="函数重载和重写虚函数">函数重载和重写虚函数</h3>
<p>在C++中同名函数有三种关系：</p>
<ul>
<li>重载
(overlode)：相同作用域；函数名相同；参数列表不同；返回类型随意。</li>
<li>覆盖
(override)：不同作用域下（分别在父类和子类中）；函数名相同；参数列表列表相同；返回类型相同（协变除外）；基类函数必须有<code>virtual</code>修饰；父类和子类的访问限定可以不同。</li>
<li>隐藏
(overhide)：不同作用域下（分别在父类和子类中）；函数名相同；除过覆盖的同名函数都是隐藏关系。</li>
</ul>
<h3 id="强制类型转换">强制类型转换</h3>
<p>c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast，主要运用于继承关系类间的强制转化，语法为：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">static_cast</span>&lt;new_<span class="keyword">type</span>&gt;      (expression)</span><br><span class="line"><span class="title">dynamic_cast</span>&lt;new_<span class="keyword">type</span>&gt;     (expression) </span><br><span class="line"><span class="title">const_cast</span>&lt;new_<span class="keyword">type</span>&gt;       (expression) </span><br><span class="line"><span class="title">reinterpret_cast</span>&lt;new_<span class="keyword">type</span>&gt; (expression)</span><br></pre></td></tr></table></figure>
<p>备注：new_type为目标数据类型，expression为原始数据类型变量或者表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(a);<span class="comment">//正确，将char型数据转换成int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> *c = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">void</span> *d = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(c);<span class="comment">//正确，将double指针转换成void指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;(e);<span class="comment">//正确，将int型数据转换成const int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *h = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;g);<span class="comment">//编译错误，static_cast不能转换掉g的const属性</span></span><br></pre></td></tr></table></figure>
<h3 id="using">using</h3>
<p>除了命名变量空间以外，<code>using</code>还可以作为类型重命名，例如这两个写法是等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt; intvec;</span><br><span class="line"><span class="keyword">using</span> intvec = std::vector&lt;<span class="type">int</span>&gt;;	</span><br></pre></td></tr></table></figure>
<h3 id="智能for">智能for</h3>
<p>格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter：itered)&#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="global_trajectory_builder.cc">global_trajectory_builder.cc</h2>
<h3 id="void-addsensordata">void AddSensorData()</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSensorData</span><span class="params">(<span class="type">const</span> std::string&amp; sensor_id,<span class="type">const</span> sensor::TimedPointCloudData&amp; timed_point_cloud_data)</span> <span class="keyword">override</span></span></span><br></pre></td></tr></table></figure>
<p>在这个<code>GlobalTrajectoryBuilder</code>类的<code>AddSensorData()</code>函数里面首先调用类的私有成员变量<code>local_trajectory_builder_</code>的<code>AddRangeData()</code>成员函数，注意这个<code>AddRangeData</code>已经不是<code>GlobalTrajectoryBuilder</code>类中的<code>AddSensorData()</code>函数了。</p>
<h2
id="local_trajectory_builder_2d.cc">local_trajectory_builder_2d.cc</h2>
<p>本文件重点 帧间匹配</p>
<h3
id="filtered_gravity_aligned_point_cloud">filtered_gravity_aligned_point_cloud</h3>
<p>点云数据的重力矫正</p>
<p>室内场景中地板是水平的， 墙壁是竖直的，
所以点云数据的重力方向应该尽可能与场景中的法线方向垂直或平行。而人工拍摄得到的深度图像因为各种因素影响很可能重力方向是倾斜的，
所以本文对点云进行重力矫正， 将其进行旋转使之与场景坐标系对准。</p>
<h3 id="scanmatch">ScanMatch()</h3>
<p><code>real_time_correlative_scan_matcher_</code>得到一个位置的解，用这个作为初始解用<code>ceres_scan_matcher_</code>优化的方法优化解。</p>
<p><code>correlative_scan_matcher_</code>的方法是基于搜索的方法。</p>
<p><code>ceres_scan_matcher_</code>的方法是基于优化的方法，优化的过程中采用梯度下降的方法，采用三次样条差值的方法使得离散栅格连续化。这种局部优化的方法很容易陷入到局部极小值当中，因此这个方法能正常工作的前提是初始值离全局最优值比较近。</p>
<h3 id="discretescan2d">DiscreteScan2D</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;Eigen::Array2i&gt; DiscreteScan2D </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Eigen::Array&lt;<span class="type">int</span>, <span class="number">2</span>, <span class="number">1</span>&gt; Eigen::Array2i</span><br></pre></td></tr></table></figure>
<h3 id="tsdf">TSDF</h3>
<p>参考：https://www.jianshu.com/p/462fe75753f7</p>
<h3 id="ceres库中的一些术语">ceres库中的一些术语</h3>
<p>优化目标 <span class="math display">\[
\begin{split}\min_{\mathbf{x}} &amp;\quad \frac{1}{2}\sum_{i}
\rho_i\left(\left\|f_i\left(x_{i_1}, ...
,x_{i_k}\right)\right\|^2\right) \\ \text{s.t.} &amp;\quad l_j \le x_j
\le u_j\end{split}
\]</span> <span class="math inline">\(\rho()\)</span> :loss function</p>
<p><span class="math inline">\(f(x)\)</span> :cost function</p>
<p>求和符号中的每一项构成一个residual block</p>
<h2 id="map">map</h2>
<h2 id="cartographer中的点云表达">cartographer中的点云表达</h2>
<p>cartographer中的点是自己封装对Eigen库的3*1的<code>matrix</code>做了一层结构体封装，原型是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带时间信息的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RangefinderPoint</span> &#123;</span><br><span class="line">  Eigen::Vector3f position;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//带时间信息的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimedRangefinderPoint</span> &#123;</span><br><span class="line">  Eigen::Vector3f position;</span><br><span class="line">  <span class="type">float</span> time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用的时候进行了重命名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> PointType = RangefinderPoint;</span><br></pre></td></tr></table></figure>
<p>点云类<code>PointCloud</code>的核心就是其私有的成员变量，<code>points_</code>，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PointCloud</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">	  std::vector&lt;PointType&gt; points_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>PointCloud</code>，此外还封装了一些诸如添加点，大小等函数。</p>
<p>一帧激光的点云数据就是在此基础上再进行一次封装。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RangeData</span> &#123;</span><br><span class="line">  Eigen::Vector3f origin; <span class="comment">//原点</span></span><br><span class="line">  PointCloud returns;     <span class="comment">//返回的</span></span><br><span class="line">  PointCloud misses;      <span class="comment">//miss点 无反射的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意这个结构体里面的<code>misses</code>点指得是发射出的激光里面那些没有收到反射值（测距超过量程了）的点，不是一般所指的那些激光线束所经过而代表的空闲点。</p>
<h2
id="cartographer中的地图的一些表达">cartographer中的地图的一些表达</h2>
<p>地图存的是一维数据，查询时先将二维xy转换为一维索引，然后查询。</p>
<p>重要基类 <code>Grid2D</code>，私有成员变量情况如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grid2D</span> : <span class="keyword">public</span> GridInterface &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  MapLimits limits_;</span><br><span class="line">  std::vector&lt;uint16&gt; correspondence_cost_cells_; <span class="comment">//记录各个栅格单元空闲概率的列表</span></span><br><span class="line">  <span class="type">float</span> min_correspondence_cost_;                 <span class="comment">//Pfree的最小值</span></span><br><span class="line">  <span class="type">float</span> max_correspondence_cost_;                 <span class="comment">//Pfree的最大值</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; update_indices_;               <span class="comment">//记录跟新过的栅格单元的索引</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bounding box of known cells to efficiently compute cropping limits.</span></span><br><span class="line">  Eigen::AlignedBox2i known_cells_box_;           <span class="comment">//一个用于记录哪个栅格单元有值的数据结构</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;* value_to_correspondence_cost_table_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>概率栅格地图继承自<code>Grid2D</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProbabilityGrid</span> : <span class="keyword">public</span> Grid2D &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">     ValueConversionTables* conversion_tables_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中重要的函数，初始化栅格地图的函数如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProbabilityGrid::SetProbability</span><span class="params">(<span class="type">const</span> Eigen::Array2i&amp; cell_index,<span class="type">const</span> <span class="type">float</span> probability)</span> </span>&#123;</span><br><span class="line">  uint16&amp; cell = (*<span class="built_in">mutable_correspondence_cost_cells</span>())[<span class="built_in">ToFlatIndex</span>(cell_index)];</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(cell, kUnknownProbabilityValue);</span><br><span class="line">  cell =  <span class="built_in">CorrespondenceCostToValue</span>(<span class="built_in">ProbabilityToCorrespondenceCost</span>(probability));</span><br><span class="line">  <span class="built_in">mutable_known_cells_box</span>()-&gt;<span class="built_in">extend</span>(cell_index.<span class="built_in">matrix</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一组概率">一组概率</h3>
<p>cartographer中一般叫<code>Probability</code>的都是占有概率，叫<code>CorrespondenceCost</code>的都是空闲概率。</p>
<h3
id="关于向地图中插入一组新的激光数据">关于向地图中插入一组新的激光数据</h3>
<p>核心函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CastRays</span><span class="params">(<span class="type">const</span> sensor::RangeData&amp; range_data, 	<span class="comment">//待插入的扫描数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> std::vector&lt;uint16&gt;&amp; hit_table,	<span class="comment">//预先计算的hit表</span></span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> std::vector&lt;uint16&gt;&amp; miss_table,<span class="comment">//预先计算的miss表</span></span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> <span class="type">bool</span> insert_free_space, ProbabilityGrid* probability_grid)</span> </span></span><br></pre></td></tr></table></figure>
<h4
id="hit_table和miss_table"><code>hit_table</code>和<code>miss_table</code></h4>
<p>提前计算好的一个occupy栅格再次被击中后应当更新的栅格值，即：</p>
<p><span class="math display">\[
hit\_table\_[Grid_{value\_old}] = Grid_{value\_new}
\]</span> miss_table同理。</p>
<p>核心步骤</p>
<ol type="1">
<li><p>记录击中点在栅格中的位置（代码中用<code>end</code>来记录，意思应该是指代表极光线束的末端），更新地图</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> sensor::RangefinderPoint&amp; hit : range_data.returns) &#123;</span><br><span class="line"> ends.<span class="built_in">push_back</span>(superscaled_limits.<span class="built_in">GetCellIndex</span>(hit.position.<span class="built_in">head</span>&lt;<span class="number">2</span>&gt;()));</span><br><span class="line">    probability_grid-&gt;<span class="built_in">ApplyLookupTable</span>(ends.<span class="built_in">back</span>()/kSubpixelScale, hit_table);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>记录原点到每一个end点之间的miss点，然后用这些点更新地图</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Eigen::Array2i&amp; end : ends) &#123;</span><br><span class="line">  std::vector&lt;Eigen::Array2i&gt; ray = <span class="built_in">RayToPixelMask</span>(begin, end, kSubpixelScale);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> Eigen::Array2i&amp; cell_index : ray) &#123;</span><br><span class="line">    probability_grid-&gt;<span class="built_in">ApplyLookupTable</span>(cell_index, miss_table);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上面两步骤中的跟新地图都通过调运<code>probability_grid-&gt;ApplyLookupTable()</code>函数完成。函数中最关键的一步即为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cell = table[*cell];</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">曾圣尧</p>
  <div class="site-description" itemprop="description">好记性不如烂笔头</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">曾圣尧</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
